<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Security Deep Dive - Confidential Computing & Hardware Security</title>
    <link rel="stylesheet" href="../../assets/css/styles.css">
    <link rel="stylesheet" href="../../assets/css/demo-enhancements.css">
    <style>
        .gpu-security-tier { background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%); }
        .confidential-computing { background: linear-gradient(135deg, #059669 0%, #047857 100%); }
        .gpu-security-component { border-left: 4px solid #7c3aed; background: #faf5ff; }
        .attestation-layer { background: #f0fdf4; border: 2px solid #059669; }
        .gpu-demo { background: #f8fafc; border: 1px solid #e2e8f0; }
        .vulnerability-alert { background: #fef2f2; border-left: 3px solid #dc2626; }
        .security-success { background: #f0fdf4; border-left: 3px solid #16a34a; }
        .firmware-security { background: #fffbeb; border: 2px solid #f59e0b; }
    </style>
</head>

<body>
    <header class="demo-header">
        <nav>
            <a href="../../index.html">ğŸ  Course Home</a>
            <a href="../module-0-crypto/index.html">ğŸ“– Module 0</a>
            <a href="index.html">ğŸ”§ Module 1</a>
        </nav>
        <h1>ğŸ® GPU Security Deep Dive</h1>
        <p>Confidential Computing, Attestation & Hardware Security</p>
    </header>

    <main class="demo-container">
        <!-- GPU Security Architecture Overview -->
        <section class="demo-section">
            <h2 class="section-title gpu-security-tier">ğŸ›¡ï¸ GPU Security Architecture Overview</h2>

            <div class="gpu-security-component">
                <h3>ğŸ—ï¸ Hardware Security Foundations</h3>
                <div class="gpu-demo">
                    <h4>NVIDIA GPU Security Features</h4>
                    <ul>
                        <li><strong>Secure Boot:</strong> Root of Trust verification from GPU firmware to driver</li>
                        <li><strong>Memory Protection:</strong> Hardware-enforced memory isolation between contexts</li>
                        <li><strong>Confidential Computing (H100):</strong> Hardware-based TEE for sensitive workloads</li>
                        <li><strong>Attestation:</strong> Remote verification of GPU firmware and configuration</li>
                        <li><strong>Virtualization Security:</strong> Hardware isolation for vGPU and MIG instances</li>
                        <li><strong>Key Management:</strong> Hardware-protected key storage and crypto operations</li>
                    </ul>

                    <h4>AMD GPU Security Features</h4>
                    <ul>
                        <li><strong>Memory Guard:</strong> Hardware memory encryption for GPU workloads</li>
                        <li><strong>Secure Memory Encryption (SME):</strong> System memory encryption integration</li>
                        <li><strong>Platform Security Processor (PSP):</strong> Dedicated security coprocessor</li>
                        <li><strong>ROCm Security:</strong> Secure runtime and driver stack</li>
                        <li><strong>Firmware Verification:</strong> Cryptographic signature validation</li>
                    </ul>

                    <h4>Intel GPU Security Features</h4>
                    <ul>
                        <li><strong>Intel TXT Integration:</strong> Trusted Execution Technology support</li>
                        <li><strong>Hardware Scheduling:</strong> Secure workload isolation and scheduling</li>
                        <li><strong>Memory Encryption:</strong> Hardware memory protection mechanisms</li>
                        <li><strong>Attestation Support:</strong> Remote verification capabilities</li>
                    </ul>
                </div>

                <h3>ğŸ” GPU Security Threat Model</h3>
                <div class="attestation-layer">
                    <h4>Attack Surface Analysis</h4>
                    <pre class="code-block">
# GPU Security Attack Surface

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                        â”‚
â”‚  â€¢ Malicious GPU kernels    â€¢ Memory corruption attacks    â”‚
â”‚  â€¢ Side-channel attacks     â€¢ Data exfiltration            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“ API/Runtime Interface
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Driver Layer                              â”‚
â”‚  â€¢ Driver vulnerabilities  â€¢ Privilege escalation          â”‚
â”‚  â€¢ Firmware backdoors     â€¢ Configuration tampering        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“ Hardware Interface
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Hardware Layer                             â”‚
â”‚  â€¢ Physical attacks        â€¢ Supply chain compromise       â”‚
â”‚  â€¢ Firmware exploitation   â€¢ Side-channel attacks          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

# Threat Categories:
1. Data Theft & Exfiltration
   - GPU memory scraping
   - Cross-tenant data leakage
   - Model extraction attacks

2. Compute Hijacking
   - Cryptojacking on GPU resources
   - Unauthorized AI model training
   - Resource exhaustion attacks

3. System Compromise
   - GPU-assisted privilege escalation
   - Firmware persistence mechanisms
   - Hardware implant activation

4. Side-Channel Attacks
   - Power analysis attacks
   - Electromagnetic emanation
   - Timing attack vectors
                    </pre>
                </div>
            </div>
        </section>

        <!-- NVIDIA Confidential Computing -->
        <section class="demo-section">
            <h2 class="section-title confidential-computing">ğŸ”’ NVIDIA Confidential Computing (H100)</h2>

            <div class="gpu-security-component">
                <h3>ğŸ›¡ï¸ Hardware-based Trusted Execution Environment</h3>

                <div class="security-success">
                    <h4>Confidential Computing Architecture</h4>
                    <ul>
                        <li><strong>Hardware TEE:</strong> Hardware-enforced isolation for sensitive GPU workloads</li>
                        <li><strong>Memory Encryption:</strong> AES-256 encryption of GPU memory contents</li>
                        <li><strong>Attestation:</strong> Remote verification of GPU firmware and configuration</li>
                        <li><strong>Key Management:</strong> Hardware root of trust for cryptographic operations</li>
                        <li><strong>Secure Communication:</strong> Encrypted channels between CPU and GPU</li>
                    </ul>

                    <h4>Confidential Computing Workflow</h4>
                    <pre class="code-block">
# NVIDIA H100 Confidential Computing Setup

# 1. Enable Confidential Computing mode
nvidia-smi -cc 1
# Confidential Computing: Enabled

# 2. Verify CC capabilities
nvidia-smi --query-gpu=cc.mode --format=csv
# cc.mode
# Enabled

# 3. Generate attestation report
nvidia-ml-py3 example:
import pynvml
pynvml.nvmlInit()

# Get GPU handle
handle = pynvml.nvmlDeviceGetHandleByIndex(0)

# Generate attestation report
attestation_report = pynvml.nvmlDeviceGetConfComputeGpuAttestationReport(handle)

# Attestation report contains:
# - GPU firmware version and hash
# - Secure boot measurements
# - Hardware configuration state
# - Cryptographic signature for remote verification

print(f"Attestation Report Length: {len(attestation_report)} bytes")
print(f"Report Hash: {hashlib.sha256(attestation_report).hexdigest()}")

# 4. Secure workload execution
# Applications running in CC mode have:
# - Encrypted memory (invisible to host OS)
# - Protected against physical attacks
# - Attestable execution environment
# - Hardware-enforced isolation
                    </pre>
                </div>

                <h3>ğŸ”‘ Key Management & Attestation</h3>
                <div class="attestation-layer">
                    <h4>Remote Attestation Protocol</h4>
                    <pre class="code-block">
# Remote Attestation Workflow

1. Attestation Request
   Client â†’ GPU: Request attestation report

2. Report Generation
   GPU Hardware â†’ Secure Processor: Generate signed report

3. Report Verification
   Client â†’ Verification Service: Validate report signature

4. Trust Establishment
   Verification Service â†’ Client: Confirm trusted state

5. Secure Communication
   Client â†” GPU: Establish encrypted channel

# Example attestation verification (Python)
import cryptography.hazmat.primitives.hashes as hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding

def verify_gpu_attestation(report, nvidia_root_cert):
    """Verify NVIDIA GPU attestation report"""

    # Extract signature and data from report
    signature = report[-256:]  # Last 256 bytes
    data = report[:-256]       # Everything else

    # Verify signature chain
    nvidia_pubkey = extract_public_key(nvidia_root_cert)

    try:
        nvidia_pubkey.verify(
            signature,
            data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True, "Attestation verified successfully"
    except Exception as e:
        return False, f"Attestation verification failed: {e}"

# Integration with enterprise key management
def establish_secure_session(gpu_attestation):
    """Establish secure session with attested GPU"""

    if verify_gpu_attestation(gpu_attestation):
        # Generate session key
        session_key = os.urandom(32)  # 256-bit AES key

        # Encrypt session key with GPU public key
        gpu_pubkey = extract_gpu_public_key(gpu_attestation)
        encrypted_key = gpu_pubkey.encrypt(
            session_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        return encrypted_key, session_key
    else:
        raise SecurityException("GPU attestation failed")
                    </pre>

                    <h4>Enterprise Integration Example</h4>
                    <pre class="code-block">
# Kubernetes Integration for Confidential GPU Computing

apiVersion: v1
kind: ConfigMap
metadata:
  name: gpu-confidential-config
data:
  nvidia-cc.conf: |
    # NVIDIA Confidential Computing Configuration
    mode=on
    attestation_required=true
    memory_protection=aes256
    secure_boot_required=true

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: confidential-ai-workload
spec:
  replicas: 1
  selector:
    matchLabels:
      app: confidential-ai
  template:
    metadata:
      labels:
        app: confidential-ai
    spec:
      containers:
      - name: ai-inference
        image: nvcr.io/nvidia/pytorch:23.08-py3-cc
        resources:
          limits:
            nvidia.com/gpu: 1
        env:
        - name: NVIDIA_CONFIDENTIAL_COMPUTE
          value: "1"
        - name: CUDA_VISIBLE_DEVICES
          value: "0"
        volumeMounts:
        - name: gpu-cc-config
          mountPath: /etc/nvidia-cc
        securityContext:
          privileged: true  # Required for CC mode
      volumes:
      - name: gpu-cc-config
        configMap:
          name: gpu-confidential-config
      nodeSelector:
        nvidia.com/gpu.confidential-compute: "true"
                    </pre>
                </div>
            </div>
        </section>

        <!-- GPU Firmware Security -->
        <section class="demo-section">
            <h2 class="section-title">ğŸ”§ GPU Firmware & Driver Security</h2>

            <div class="firmware-security">
                <h3>âš™ï¸ Firmware Security Architecture</h3>

                <div class="gpu-demo">
                    <h4>NVIDIA Firmware Security</h4>
                    <ul>
                        <li><strong>Secure Boot:</strong> Cryptographic verification of firmware integrity</li>
                        <li><strong>Firmware Signing:</strong> RSA-4096 signatures for all firmware components</li>
                        <li><strong>Version Rollback Protection:</strong> Prevents downgrade to vulnerable versions</li>
                        <li><strong>Runtime Integrity:</strong> Continuous firmware integrity monitoring</li>
                        <li><strong>Secure Update:</strong> Authenticated firmware update mechanisms</li>
                    </ul>

                    <h4>Firmware Security Commands</h4>
                    <pre class="code-block">
# NVIDIA GPU firmware security operations

# Check firmware version and security status
nvidia-smi --query-gpu=vbios_version,inforom.img --format=csv
# vbios_version, inforom.img
# 96.00.5F.00.01, G001.0000.03.04

# Verify firmware signatures
nvidia-smi --query-gpu=enforced.power.limit,max.power.limit --format=csv

# Update firmware (requires specific privileges)
nvidia-firmware-update --gpu=0 --firmware=H100_firmware_v2.1.signed

# Check secure boot status
nvidia-smi --query-gpu=accounting.mode,accounting.buffer_size --format=csv

# Firmware integrity verification
nvidia-ml-py3 example:
import pynvml

pynvml.nvmlInit()
handle = pynvml.nvmlDeviceGetHandleByIndex(0)

# Get firmware version
vbios_version = pynvml.nvmlDeviceGetVbiosVersion(handle)
print(f"VBIOS Version: {vbios_version}")

# Verify InfoROM integrity
try:
    inforom_version = pynvml.nvmlDeviceGetInforomVersion(handle, pynvml.NVML_INFOROM_OEM)
    print(f"InfoROM OEM Version: {inforom_version}")
except pynvml.NVMLError as e:
    print(f"InfoROM verification failed: {e}")

# Check for firmware anomalies
firmware_status = pynvml.nvmlDeviceGetCurrentClocksThrottleReasons(handle)
if firmware_status != pynvml.NVML_CLOCKS_THROTTLE_REASON_NONE:
    print("WARNING: GPU firmware anomaly detected")
                    </pre>
                </div>

                <h3>ğŸš¨ Firmware Vulnerability Management</h3>
                <div class="vulnerability-alert">
                    <h4>Common Firmware Attack Vectors</h4>
                    <ul>
                        <li><strong>Firmware Downgrade:</strong> Rollback to vulnerable firmware versions</li>
                        <li><strong>Unsigned Firmware:</strong> Installation of malicious unsigned firmware</li>
                        <li><strong>VBIOS Modification:</strong> Tampering with video BIOS configuration</li>
                        <li><strong>InfoROM Corruption:</strong> Corruption of GPU information ROM</li>
                        <li><strong>Driver Injection:</strong> Malicious driver installation and loading</li>
                    </ul>

                    <h4>Historical GPU Security Vulnerabilities</h4>
                    <pre class="code-block">
# Recent GPU Security CVEs (Educational Analysis)

CVE-2022-34665 (NVIDIA GPU Display Driver):
- Severity: High (CVSS 8.5)
- Impact: Local privilege escalation
- Affected: Multiple GPU families
- Mitigation: Driver update to 516.94+

CVE-2022-34666 (NVIDIA vGPU Manager):
- Severity: High (CVSS 7.1)
- Impact: Information disclosure, DoS
- Affected: Virtual GPU environments
- Mitigation: vGPU software update

CVE-2021-1056 (NVIDIA GPU Display Driver):
- Severity: High (CVSS 7.8)
- Impact: Code execution, privilege escalation
- Attack Vector: Local access via vulnerable driver
- Root Cause: Improper input validation

# Vulnerability Assessment Commands
nvidia-smi --query-gpu=driver_version --format=csv
nvidia-bug-report.sh  # Generates comprehensive system report

# Check for known vulnerable driver versions
DRIVER_VERSION=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader)
if [[ "$DRIVER_VERSION" < "516.94" ]]; then
    echo "WARNING: Driver version $DRIVER_VERSION is vulnerable"
    echo "Update to 516.94 or later immediately"
fi
                    </pre>
                </div>

                <div class="security-success">
                    <h4>âœ… Firmware Security Best Practices</h4>
                    <ul>
                        <li><strong>Automated Updates:</strong> Deploy firmware updates through configuration management</li>
                        <li><strong>Signature Verification:</strong> Always verify firmware signatures before installation</li>
                        <li><strong>Version Control:</strong> Maintain strict version control and rollback procedures</li>
                        <li><strong>Monitoring:</strong> Continuous monitoring for firmware integrity and anomalies</li>
                        <li><strong>Access Controls:</strong> Restrict firmware update privileges to authorized personnel</li>
                    </ul>

                    <h4>Automated Firmware Management</h4>
                    <pre class="code-block">
#!/bin/bash
# GPU Firmware Security Management Script

REQUIRED_DRIVER_VERSION="535.104.05"
REQUIRED_VBIOS_VERSION="96.00.5F.00.01"

function check_gpu_security() {
    echo "=== GPU Security Assessment ==="

    # Check driver version
    CURRENT_DRIVER=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader,nounits | head -1)
    echo "Current Driver: $CURRENT_DRIVER"
    echo "Required Driver: $REQUIRED_DRIVER_VERSION"

    if [[ "$CURRENT_DRIVER" < "$REQUIRED_DRIVER_VERSION" ]]; then
        echo "âŒ CRITICAL: Driver version is vulnerable"
        echo "Action: Update driver immediately"
        return 1
    fi

    # Check VBIOS version
    CURRENT_VBIOS=$(nvidia-smi --query-gpu=vbios_version --format=csv,noheader | head -1)
    echo "Current VBIOS: $CURRENT_VBIOS"

    # Check for firmware anomalies
    THROTTLE_REASONS=$(nvidia-ml-py -c "
import pynvml
pynvml.nvmlInit()
handle = pynvml.nvmlDeviceGetHandleByIndex(0)
reasons = pynvml.nvmlDeviceGetCurrentClocksThrottleReasons(handle)
print(reasons)
")

    if [[ "$THROTTLE_REASONS" != "0" ]]; then
        echo "âš ï¸  WARNING: GPU throttling detected - possible firmware issue"
        logger -t gpu-security "GPU throttling detected on $(hostname)"
    fi

    # Check InfoROM integrity
    nvidia-smi --query-gpu=inforom.img --format=csv,noheader | while read inforom; do
        if [[ -z "$inforom" ]] || [[ "$inforom" == "N/A" ]]; then
            echo "âŒ CRITICAL: InfoROM integrity compromised"
            return 1
        fi
    done

    echo "âœ… GPU firmware security check passed"
    return 0
}

function update_gpu_firmware() {
    echo "=== GPU Firmware Update Process ==="

    # Backup current configuration
    nvidia-smi -q > "/backup/gpu-config-$(date +%Y%m%d-%H%M%S).txt"

    # Download and verify firmware
    FIRMWARE_URL="https://download.nvidia.com/firmware/H100_firmware_v2.1.signed"
    FIRMWARE_SIG="https://download.nvidia.com/firmware/H100_firmware_v2.1.sig"

    wget -q "$FIRMWARE_URL" -O /tmp/gpu_firmware.bin
    wget -q "$FIRMWARE_SIG" -O /tmp/gpu_firmware.sig

    # Verify firmware signature
    if ! gpg --verify /tmp/gpu_firmware.sig /tmp/gpu_firmware.bin; then
        echo "âŒ CRITICAL: Firmware signature verification failed"
        exit 1
    fi

    # Apply firmware update
    echo "Applying firmware update..."
    nvidia-firmware-update --gpu=all --firmware=/tmp/gpu_firmware.bin --force

    # Verify update success
    sleep 10
    if check_gpu_security; then
        echo "âœ… Firmware update completed successfully"
        logger -t gpu-security "GPU firmware updated successfully on $(hostname)"
    else
        echo "âŒ CRITICAL: Firmware update verification failed"
        exit 1
    fi
}

# Main execution
if ! check_gpu_security; then
    echo "Starting firmware update process..."
    update_gpu_firmware
fi
                    </pre>
                </div>
            </div>
        </section>

        <!-- Multi-Tenant GPU Security -->
        <section class="demo-section">
            <h2 class="section-title">ğŸ¢ Multi-Tenant GPU Security</h2>

            <div class="gpu-security-component">
                <h3>ğŸ”’ Hardware-Level Isolation</h3>

                <div class="attestation-layer">
                    <h4>Multi-Instance GPU (MIG) Security</h4>
                    <ul>
                        <li><strong>Hardware Partitioning:</strong> Dedicated SM units and memory per tenant</li>
                        <li><strong>Cache Isolation:</strong> Separate L2 cache slices prevent data leakage</li>
                        <li><strong>Memory Protection:</strong> Hardware-enforced memory boundaries</li>
                        <li><strong>Context Isolation:</strong> Separate execution contexts per MIG instance</li>
                        <li><strong>Fault Isolation:</strong> Errors in one instance don't affect others</li>
                    </ul>

                    <h4>Secure MIG Configuration</h4>
                    <pre class="code-block">
# Secure Multi-Instance GPU Setup

# 1. Enable MIG mode with security constraints
nvidia-smi -mig 1 --security-mode=strict

# 2. Create secure MIG instances with isolation
nvidia-smi mig -cgi 1g.10gb,2g.20gb,4g.40gb \
    --compute-instance-placement=spread \
    --memory-isolation=strict

# 3. Verify isolation configuration
nvidia-smi mig -lgip
# GPU 0 Profile ID 19 Placement ID 0: MIG 1g.10gb (ID 1)
#   Isolation: Memory=Strict, Compute=Hardware
#   Security: Tenant=A, Context=Isolated

# 4. Assign instances to specific tenants with RBAC
# Kubernetes GPU device plugin configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: nvidia-device-plugin-config
data:
  config.yaml: |
    version: v1
    sharing:
      timeSlicing:
        resources:
        - name: nvidia.com/gpu
          replicas: 4
    migStrategy: mixed
    securityPolicy:
      enforceIsolation: true
      requireAttestation: true
      allowedProfiles:
        - "1g.10gb"
        - "2g.20gb"
        - "4g.40gb"
      tenantMapping:
        "tenant-a": ["1g.10gb"]
        "tenant-b": ["2g.20gb"]
        "tenant-c": ["4g.40gb"]

# 5. Monitor inter-tenant isolation
nvidia-ml-py3 isolation monitoring:
import pynvml

def monitor_mig_isolation():
    pynvml.nvmlInit()

    # Get all MIG devices
    device_count = pynvml.nvmlDeviceGetCount()

    for i in range(device_count):
        handle = pynvml.nvmlDeviceGetHandleByIndex(i)

        # Check if MIG is enabled
        try:
            mig_mode = pynvml.nvmlDeviceGetMigMode(handle)
            if mig_mode[0] == 1:  # MIG enabled

                # Get MIG device handles
                max_mig = pynvml.nvmlDeviceGetMaxMigDeviceCount(handle)

                for j in range(max_mig):
                    try:
                        mig_handle = pynvml.nvmlDeviceGetMigDeviceHandleByIndex(handle, j)

                        # Monitor memory isolation
                        mem_info = pynvml.nvmlDeviceGetMemoryInfo(mig_handle)

                        # Check for isolation violations
                        util = pynvml.nvmlDeviceGetUtilizationRates(mig_handle)

                        print(f"MIG Device {j}: Memory={mem_info.used/1024**3:.1f}GB, GPU Util={util.gpu}%")

                        # Alert on unexpected cross-instance activity
                        if detect_isolation_violation(mig_handle):
                            print(f"âš ï¸ SECURITY ALERT: Isolation violation detected in MIG instance {j}")

                    except pynvml.NVMLError:
                        continue

        except pynvml.NVMLError:
            continue
                    </pre>
                </div>

                <h3>ğŸ” Virtualization Security (vGPU)</h3>
                <div class="security-success">
                    <h4>NVIDIA vGPU Security Architecture</h4>
                    <ul>
                        <li><strong>Hypervisor Integration:</strong> Secure integration with VMware vSphere, Citrix, etc.</li>
                        <li><strong>Guest-Host Isolation:</strong> Hardware-enforced isolation between VMs</li>
                        <li><strong>Memory Encryption:</strong> Encrypted GPU memory for sensitive VMs</li>
                        <li><strong>Attestation:</strong> Remote attestation of vGPU environment integrity</li>
                        <li><strong>Resource Allocation:</strong> Secure and fair resource allocation per VM</li>
                    </ul>

                    <h4>Secure vGPU Deployment</h4>
                    <pre class="code-block">
# VMware vSphere vGPU Security Configuration

# vGPU profile with security constraints
vgpu_profile:
  name: "grid_h100-4c"
  framebuffer: "4096MB"
  max_resolution: "4096x2160"
  security_features:
    memory_encryption: true
    attestation_required: true
    guest_isolation: "strict"
    frame_rate_limiter: true

# ESXi host configuration
esxcfg-advcfg -s 1 /Misc/PreferHDD
esxcfg-advcfg -s 1 /VGPU/HostChannelVerification

# VM security policy
vm_security_policy:
  encrypted_vmotion: true
  secure_boot: true
  vtpm_enabled: true
  vgpu_security:
    isolation_mode: "strict"
    memory_encryption: "aes256"
    attestation_policy: "required"

# vCenter GPU allocation with security
$spec = New-Object VMware.Vim.VirtualMachineConfigSpec
$spec.deviceChange = New-Object VMware.Vim.VirtualDeviceConfigSpec[] (1)
$spec.deviceChange[0] = New-Object VMware.Vim.VirtualDeviceConfigSpec
$spec.deviceChange[0].operation = "add"

$vgpu = New-Object VMware.Vim.VirtualPCIPassthrough
$vgpu.backing = New-Object VMware.Vim.VirtualPCIPassthroughVmiopBackingInfo
$vgpu.backing.vgpu = "grid_h100-4c"
$vgpu.backing.securityPolicy = "strict"

# Apply security configuration
$vm | Set-VM -Spec $spec -Confirm:$false
                    </pre>
                </div>
            </div>
        </section>

        <!-- Interactive GPU Security Demo -->
        <section class="demo-section">
            <h2 class="section-title">ğŸ® Interactive GPU Security Demo</h2>

            <div class="demo-controls">
                <button onclick="demonstrateConfidentialComputing()" class="demo-button">
                    ğŸ”’ Confidential Computing
                </button>
                <button onclick="simulateGPUAttack()" class="demo-button">
                    âš ï¸ Security Attack Simulation
                </button>
                <button onclick="showFirmwareSecurity()" class="demo-button">
                    ğŸ”§ Firmware Security
                </button>
                <button onclick="auditGPUCompliance()" class="demo-button">
                    ğŸ“‹ Security Compliance Audit
                </button>
            </div>

            <div id="gpu-security-demo-output" class="demo-output">
                <p>Click any button above to explore GPU security features, attack simulations, and compliance auditing.</p>
            </div>
        </section>
    </main>

    <footer class="demo-footer">
        <div class="footer-nav">
            <a href="nvme-security-deep-dive.html">â† NVMe Security</a>
            <a href="supply-chain-security.html">Supply Chain Security â†’</a>
        </div>
        <p>&copy; 2024 DataCenter Hardware Security Course. Educational content for masters-level study.</p>
    </footer>

    <script src="gpu-security-demo.js"></script>
</body>
</html>